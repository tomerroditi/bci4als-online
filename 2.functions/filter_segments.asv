function filt_data = filter_segments(segments, cont_or_disc, constants)
% this function is aplying the preprocess filtering phase in the pipeline. 
% It filters the data using BP and notch filters.
%
% Inputs:
%   - segments: a 4D matrix containing the segmented raw data, its
%   dimentions are [electrodes, time, channels, trials].
%   - cont_or_disc: a string specifying if the segmentation type is
%   continuous or discrete.
%   - constants: a Constants object containing some constants for the
%   preprocessing process.
%
% Output:
%   - postprocces_segments: a 4D matrix of the segments after being
%   preproccesed, the dimentions order are the same as in 'segments'

% Notes - add in the future:
% - see comments in the end the script

% define some usefull variables
num_trials   = size(segments,4);
num_channels = size(segments,1);

% import some constants for the filters design and filtering 
buff_start   = constants.buffer_start;
buff_end     = constants.buffer_end;
Fs           = constants.sample_rate;
high_freq    = constants.high_freq;
low_freq     = constants.low_freq;
high_width   = constants.high_width;
low_width    = constants.low_width;
notch_freq   = constants.notch;
notch_width  = constants.notch_width;

% implement a bandpass filter and a notch filter.
% we will use IIR filters to get faster preprocessing in the online sessions.

persistent BP_filter notch_filter; 

if isempty(BP_filter)
    % design an IIR bandpass filter
    h_bp = fdesign.bandpass('fst1,fp1,fp2,fst2,ast1,ap,ast2', low_freq - low_width, low_freq, ...
    high_freq, high_freq + high_width, 60, 1, 60, Fs);
    
    BP_filter = design(h_bp, 'cheby1', ...
        'MatchExactly', 'passband', ...
        'SOSScaleNorm', 'Linf');
    
    % design an IIR notch filters 
    N  = 6;            % Order
    F0 = notch_freq;   % Center frequencies
    BW = notch_width;  % Bandwidth
    
    notch_filter = cell(length(F0),1);
    for freq = 1:length(F0)
        h = fdesign.notch('N,F0,BW', N, F0(freq), BW, Fs);
        notch_filter{freq} = design(h, 'butter', 'SOSScaleNorm', 'Linf');
    end
end

trial_length = size(segments,2);
filt_data = zeros(num_channels,trial_length - buff_start - buff_end, 1, num_trials);

% filter the data and remove eog artifacts
% NOTICE that there is not difference between cont and disc for now we
% might change it later if needed!
bss_opt.bss_alg = 'iWASOBI';

if strcmp(cont_or_disc, 'discrete')
    for i = 1:num_trials
        % BP filtering
        temp = filter(BP_filter, squeeze(segments(:,:,:,i)).');
        temp = temp.';
        % notch filtering
        for j = 1:length(notch_filter)
            temp = filter(notch_filter{j}, temp, 2);
        end

        if constants.eog_artifact
            % eog artifact removal
            [~, temp] = evalc('autobss(temp(:,buff_start + 1:end - buff_end), bss_opt)');
            % allocate the cleared data into the new matrix
            filt_data(:,:,:,i) = temp;
        else
            filt_data(:,:,:,i) = temp(:,buff_start + 1:end - buff_end); % allocate the filtered data into the new matrix
        end
    end
elseif strcmp(cont_or_disc, 'continuous')
    for i = 1:num_trials
        % BP filtering
        temp = filter(BP_filter, squeeze(segments(:,:,:,i)).');
        temp = temp.';
        % notch filtering
        for j = 1:length(notch_filter)
            temp = filter(notch_filter{j}, temp, 2);
        end

        if constants.eog_artifact
            % eog artifact removal
            [~, temp] = evalc('autobss(temp(:,buff_start + 1:end - buff_end), bss_opt)');
            filt_data(:,:,:,i) = temp; % allocate the cleared data into the new matrix
        else
            filt_data(:,:,:,i) = temp(:,buff_start + 1:end - buff_end); % allocate the filtered data into the new matrix
        end
    end
    if constants.avg_reference
        filt_data = filt_data - mean(filt_data);
    end
end

end

% consider adding in the future
% % remove blinks
% EEG = pop_autobsseog( EEG, 128, 128, 'sobi', {'eigratio', 1000000}, 'eog_fd', {'range',[1  5]});
% EEG = pop_autobssemg( EEG, 5.12, 5.12, 'bsscca', {'eigratio', 1000000}, 'emg_psd', {'ratio', [10],'fs', 125,'femg', 15,'estimator', spectrum.welch({'Hamming'}, 62),'range', [0  8]});

% Automatic noise rejection using pop_rejcont
% if Configuration.PREPROCESS_NOISE_REJECTION ~= 0
%     [~, V_Rejected_Sample_Range] = pop_rejcont(EEG, 'elecrange', [1:EEG.nbchan] ,'freqlimit', [Configuration.PREPROCESS_LOW_PASS Configuration.PREPROCESS_HIGH_PASS] , 'threshold', 10, 'epochlength', 0.5, 'contiguous', 4, 'addlength', 0.25, 'taper', 'hamming');
%     EEG = pop_select(EEG, 'nopoint',V_Rejected_Sample_Range);
% end

% Apply LaPlacian Filter
% if Configuration.PREPROCESS_LAPLACIAN ~= 0
%     EEG.data(1,:) = EEG.data(1,:) - ((EEG.data(3,:) + EEG.data(5,:) + EEG.data(7,:) + EEG.data(9,:))./4);
%     EEG.data(2,:) = EEG.data(2,:) - ((EEG.data(4,:) + EEG.data(6,:) + EEG.data(8,:) + EEG.data(10,:))./4);
% end                